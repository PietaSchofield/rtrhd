% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_type_views.R
\name{make_typed_views}
\alias{make_typed_views}
\title{Create typed DuckDB views from an Excel data dictionary (one sheet per table)}
\usage{
make_typed_views(
  con,
  datadict_path,
  name_col = "name",
  type_col = "type",
  only_tables = NULL
)
}
\arguments{
\item{con}{A DBI DBIConnection to DuckDB.}

\item{datadict_path}{Path to the Excel workbook (e.g., "gold_v26.xlsx").}

\item{name_col}{Column name in each sheet containing variable names.
Default \code{"name"}.}

\item{type_col}{Column name in each sheet containing desired types.
Default \code{"type"}.}

\item{only_tables}{Optional character vector of table names; if supplied,
only those sheets/tables are processed.}
}
\value{
Invisibly, a named list. For each table, a list with
\code{$matched} and \code{$unmatched} data frames describing mapping.
}
\description{
Assumes one Excel sheet per table, with the sheet name matching the DuckDB
table name. The sheet must contain at least two columns: a variable name
column and a data type column. Raw tables remain all-VARCHAR; this builds
\verb{<table>__typed} views that CAST matching columns.
}
\details{
Name matching is tolerant:
\itemize{
\item names are lowercased, trimmed, and non-alphanumerics collapsed to \verb{_}
\item exact normalised matches are cast; others stay as text
}
}
\examples{
\dontrun{
make_typed_views(
  con           = dbcon,
  datadict_path = "gold_v26.xlsx",
  name_col      = "name",
  type_col      = "type"
)
}
}
